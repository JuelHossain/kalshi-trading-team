"""
Soul snapshot manager.

Creates and manages soul snapshots for significant changes.
"""

import re
import hashlib
from pathlib import Path
from typing import List, Optional, Dict
from datetime import datetime

from scripts.evolution.updaters import BaseUpdater
from scripts.evolution.analyzer import ChangeAnalysis
from scripts.evolution.git_utils import GitUtils


class SoulUpdater(BaseUpdater):
    """Manages soul snapshots for significant changes."""

    SOUL_DIR = Path("ai-env/soul")
    ARCHIVES_DIR = SOUL_DIR / "archives"
    IDENTITY_FILE = SOUL_DIR / "identity.md"

    def __init__(self):
        self.git = GitUtils()
        self._ensure_directories()

    def _ensure_directories(self) -> None:
        """Ensure required directories exist."""
        self.ARCHIVES_DIR.mkdir(parents=True, exist_ok=True)

    def can_handle(self, target: str) -> bool:
        """Check if this updater can handle the target."""
        return 'soul' in target.lower() or 'snapshot' in target.lower()

    def update(self, target: str, analysis: ChangeAnalysis) -> List[str]:
        """
        Update soul documentation (creates snapshot if significant).

        Args:
            target: The documentation target
            analysis: The change analysis

        Returns:
            List of updated files
        """
        updated = []

        if analysis.triggers_soul and analysis.is_significant:
            snapshot_path = self.create_snapshot(analysis)
            if snapshot_path:
                updated.append(snapshot_path)

                # Also update identity.md with evolution context
                if self._update_identity_with_evolution(analysis):
                    updated.append(str(self.IDENTITY_FILE))

        return updated

    def create_snapshot(self, analysis: ChangeAnalysis) -> Optional[str]:
        """
        Create a soul snapshot for significant changes.

        Args:
            analysis: The change analysis

        Returns:
            Path to the created snapshot file
        """
        try:
            # Generate snapshot filename
            timestamp = datetime.now()
            date_str = timestamp.strftime('%Y-%m-%d')
            time_str = timestamp.strftime('%H%M%S')

            # Create a short hash of the changes
            changes_hash = self._hash_changes(analysis)

            snapshot_name = f"soul_snapshot_{date_str}_{time_str}_{changes_hash}.md"
            snapshot_path = self.ARCHIVES_DIR / snapshot_name

            # Generate snapshot content
            content = self._generate_snapshot_content(analysis, timestamp)

            # Write snapshot
            snapshot_path.write_text(content, encoding='utf-8')

            print(f"Created soul snapshot: {snapshot_path}")
            return str(snapshot_path)

        except Exception as e:
            print(f"Error creating soul snapshot: {e}")
            return None

    def _hash_changes(self, analysis: ChangeAnalysis) -> str:
        """Generate a short hash of the changes for the filename."""
        hasher = hashlib.md5()
        for change in sorted(analysis.changes, key=lambda c: c.file_path):
            hasher.update(change.file_path.encode())
            hasher.update(change.status.encode())
        return hasher.hexdigest()[:8]

    def _generate_snapshot_content(
        self,
        analysis: ChangeAnalysis,
        timestamp: datetime
    ) -> str:
        """Generate the content for a soul snapshot."""
        commit_info = self.git.get_last_commit_info()

        content = f"""# Soul Snapshot - {timestamp.strftime('%Y-%m-%d %H:%M:%S')}

## Evolution Event

**Timestamp**: {timestamp.isoformat()}
**Commit**: {commit_info.get('hash', 'unknown')[:8]}
**Author**: {commit_info.get('author_name', 'unknown')}

## Significance

This snapshot was triggered because:

{chr(10).join(f"- {reason}" for reason in analysis.significance_reasons)}

## Changes

### Files Modified ({len(analysis.changes)})

| File | Status | Lines (+/-) |
|------|--------|-------------|
"""
        for change in analysis.changes:
            content += f"| `{change.file_path}` | {change.status} | +{change.lines_added}/-{change.lines_removed} |\n"

        content += f"""
### Change Types

{chr(10).join(f"- `{ct.value}`" for ct in analysis.change_types)}

### Documentation Targets

{chr(10).join(f"- `{target}`" for target in sorted(analysis.doc_targets))}

## System State

### Current Branch
```
{self.git.get_current_branch()}
```

### Commit Message
```
{commit_info.get('message', 'N/A')}
```

## Evolution Context

This snapshot captures a significant evolution in the Sentient Alpha system.
The changes documented here represent a material shift in:

{self._generate_impact_summary(analysis)}

---

*Generated by the Sentient Alpha Evolution System*
*Snapshot ID: {self._hash_changes(analysis)}*
"""
        return content

    def _generate_impact_summary(self, analysis: ChangeAnalysis) -> str:
        """Generate a summary of the impact of changes."""
        summaries = []

        for change_type in analysis.change_types:
            if change_type.value == 'agent_logic':
                summaries.append("- **Agent Decision Logic**: Core trading decision algorithms")
            elif change_type.value == 'schema_change':
                summaries.append("- **Data Schema**: Inter-agent communication protocols")
            elif change_type.value == 'core_logic':
                summaries.append("- **System Core**: Fundamental system operations")
            elif change_type.value == 'frontend_change':
                summaries.append("- **User Interface**: Dashboard and visualization")
            elif change_type.value == 'workflow_change':
                summaries.append("- **Operational Workflows**: Agent procedures and protocols")
            elif change_type.value == 'skill_change':
                summaries.append("- **AI Skills**: Agent capabilities and knowledge")

        if not summaries:
            summaries.append("- **General Evolution**: System-wide improvements")

        return "\n".join(summaries)

    def _update_identity_with_evolution(self, analysis: ChangeAnalysis) -> bool:
        """
        Update identity.md with evolution context.

        Args:
            analysis: The change analysis

        Returns:
            True if updated successfully
        """
        try:
            if not self.IDENTITY_FILE.exists():
                return False

            content = self.IDENTITY_FILE.read_text(encoding='utf-8')

            # Generate evolution entry
            timestamp = datetime.now().strftime('%Y-%m-%d')
            commit_info = self.git.get_last_commit_info()
            short_hash = commit_info.get('hash', 'unknown')[:8]

            # Create summary of changes
            change_summary = self._summarize_changes(analysis)

            evolution_entry = f"""### [{timestamp}] Evolution Event ({short_hash})
**Snapshot**: {change_summary}

**Files**: {len(analysis.changes)} changed
**Types**: {', '.join(ct.value for ct in analysis.change_types)}
**Significance**: {', '.join(analysis.significance_reasons[:2])}

"""

            # Insert after "## Recent Intuition (READ ONLY LATEST)"
            section_marker = "## Recent Intuition (READ ONLY LATEST)"
            if section_marker in content:
                insert_pos = content.find(section_marker) + len(section_marker)
                content = content[:insert_pos] + "\n\n" + evolution_entry + content[insert_pos:]
            else:
                # Append at end
                content = content.rstrip() + "\n\n" + evolution_entry

            self.IDENTITY_FILE.write_text(content, encoding='utf-8')
            return True

        except Exception as e:
            print(f"Error updating identity with evolution: {e}")
            return False

    def _summarize_changes(self, analysis: ChangeAnalysis) -> str:
        """Generate a brief summary of changes."""
        # Get the most significant change types
        priority_types = ['agent_logic', 'schema_change', 'core_logic']

        for pt in priority_types:
            for ct in analysis.change_types:
                if ct.value == pt:
                    return f"{ct.value.replace('_', ' ').title()} evolution"

        if analysis.change_types:
            return f"{list(analysis.change_types)[0].value.replace('_', ' ').title()} update"

        return "System evolution"

    def list_snapshots(self) -> List[Path]:
        """List all available soul snapshots."""
        if not self.ARCHIVES_DIR.exists():
            return []

        snapshots = sorted(
            self.ARCHIVES_DIR.glob("soul_snapshot_*.md"),
            key=lambda p: p.stat().st_mtime,
            reverse=True
        )
        return snapshots

    def get_latest_snapshot(self) -> Optional[Path]:
        """Get the most recent soul snapshot."""
        snapshots = self.list_snapshots()
        return snapshots[0] if snapshots else None

    def cleanup_old_snapshots(self, keep_count: int = 50) -> int:
        """
        Remove old snapshots, keeping only the most recent.

        Args:
            keep_count: Number of snapshots to keep

        Returns:
            Number of snapshots removed
        """
        snapshots = self.list_snapshots()

        if len(snapshots) <= keep_count:
            return 0

        removed = 0
        for snapshot in snapshots[keep_count:]:
            try:
                snapshot.unlink()
                removed += 1
            except Exception as e:
                print(f"Warning: Could not remove {snapshot}: {e}")

        return removed
